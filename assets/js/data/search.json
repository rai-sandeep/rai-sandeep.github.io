[ { "title": "Spring WebFlux with WebSockets for Real-time Data", "url": "/posts/spring-webflux-with-websockets-for-real-time-data/", "categories": "Spring WebFlux, WebSockets", "tags": "java, springboot, spring-webflux, websockets", "date": "2023-01-22 12:10:00 +0530", "snippet": "Spring WebFlux with WebSockets for Real-time DataIn this tutorial, we will learn how to use Spring WebFlux to stream real-time sensor data to a web client using WebSockets. We’ll start by creating a simple Spring Boot application and then implement a WebSocket endpoint to stream the sensor data.Setting up the ProjectTo get started, we’ll create a new Spring Boot project with the WebFlux dependency:&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;&lt;/dependency&gt;Creating the WebSocket EndpointNow that we have the dependencies set up, we can create a SensorDataHandler class that will handle the WebSocket connections and stream the sensor data:@Componentpublic class SensorDataHandler implements WebSocketHandler { private final Flux&lt;String&gt; sensorData; public SensorDataHandler() { this.sensorData = Flux.interval(Duration.ofSeconds(1)) .map(s -&gt; s.toString()) .share(); } @Override public Mono&lt;Void&gt; handle(WebSocketSession session) { \treturn session.send(sensorData.map(session::textMessage)); }}In this example, the SensorDataHandler class creates a Flux of sensor data that is emitted every second. In this example, the data is just a sequence of long numbers incrementing every second. The handle method of the SensorDataHandler overrides the method from **WebSocketHandler** and returns the data. The client can connect to this endpoint using a WebSocket and receive the sensor data in real-time.Configuring the WebSocket EndpointTo configure the WebSocket endpoint, we’ll create a WebSocketConfig class and define a HandlerMapping to map the handle method to the /sensors endpoint:@Configurationpublic class WebSocketConfig {\t@Bean\tHandlerMapping webSocketHandlerMapping(SensorDataHandler handler) {\t Map&lt;String, WebSocketHandler&gt; map = new HashMap&lt;&gt;();\t map.put(\"/sensors\", handler);\t SimpleUrlHandlerMapping handlerMapping = new SimpleUrlHandlerMapping();\t handlerMapping.setOrder(1);\t handlerMapping.setUrlMap(map);\t return handlerMapping;\t}}In this class we have a webSocketHandlerMapping method that maps the handle method of the SensorDataHandler class to the /sensors endpoint.Testing the WebSocket EndpointTo test the WebSocket endpoint, we’ll create a simple HTML page with JavaScript code to connect to the WebSocket endpoint and display the sensor data in real-time. Here’s an example of how to do this using the WebSocket API:&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Sensor Data&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"sensor-data\"&gt;&lt;/div&gt; &lt;script&gt; var socket = new WebSocket(\"ws://localhost:8080/sensors\"); socket.onmessage = function(event) { var data = JSON.parse(event.data); var div = document.getElementById(\"sensor-data\"); div.innerHTML += \" value: \" + data + \"&lt;br&gt;\"; }; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;This code creates a new WebSocket object and opens a connection to the /sensors endpoint. When new sensor data is received, the onmessage callback function is called, which parses the JSON data and displays it on the page.ConclusionIn this tutorial, we’ve learned how to use Spring WebFlux to stream real-time sensor data to a web client using WebSockets. We’ve seen how to create a simple Spring Boot application and implement a WebSocket endpoint to stream the sensor data. We also saw how to configure the WebSocket endpoint and test it using a simple HTML page with JavaScript code.You can find the full code in this GitHub Repository." }, { "title": "Spring WebFlux and DB2 with rxjava2-jdbc", "url": "/posts/spring-webflux-and-db2-with-rxjava2-jdbc/", "categories": "Spring WebFlux, DB2", "tags": "java, springboot, spring-webflux, reactive, db2, rxjava2-jdbc", "date": "2022-08-05 12:30:00 +0530", "snippet": "1. OverviewIn this article, we’re going to focus on connecting to a DB2 database from a Java Spring WebFlux application using non-blocking connection pools. We’ll use rxjava2-jdbc for this purpose.The primary reason for choosing rxjava2-jdbc is that there is no native implementation for a reactive DB2 driver in r2dbc or Spring Data R2DBC. Thankfully, rxjava2-jdbc has the ability to take a normal JDBC driver and interact with it in a way that won’t block the application.2. DependenciesTo use rxjava2-jdbc with db2, add the following dependencies:&lt;dependency&gt; &lt;groupId&gt;com.github.davidmoten&lt;/groupId&gt; &lt;artifactId&gt;rxjava2-jdbc&lt;/artifactId&gt; &lt;version&gt;0.2.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.ibm.db2.jcc&lt;/groupId&gt; &lt;artifactId&gt;db2jcc&lt;/artifactId&gt; &lt;version&gt;db2jcc4&lt;/version&gt;&lt;/dependency&gt;See mvnrepository for latest version of rxjava2-jdbc.3. ConfigurationCreate a Database bean with a non-blocking connection pool:@Beanpublic Database database() { return Database.nonBlocking() .url(\"jdbc:db2://localhost:50000/testdb:currentSchema=DB2INST1;\") .user(\"db2inst1\") .password(\"testpass\") .maxPoolSize(25) .build();}If you do not have a DB2 database for local testing, you can quickly set up one with Docker:docker run -itd --name db2 -e DBNAME=testdb -e DB2INST1_PASSWORD=testpass -e LICENSE=accept -p 50000:50000 --privileged=true ibmcom/db2You may also want to connect to the database, create a table and insert some data for testing:CREATE TABLE EMPLOYEE(ID INTEGER NOT NULL, NAME CHAR (30));INSERT INTO DB2INST1.EMPLOYEE (ID, NAME) VALUES(10, 'James Bond'); INSERT INTO DB2INST1.EMPLOYEE (ID, NAME) VALUES(20, 'Harry Potter'); INSERT INTO DB2INST1.EMPLOYEE (ID, NAME) VALUES(30, 'Bruce Wayne');4. Querying the DatabaseUse the database bean created above to run queries:public Flux&lt;Employee&gt; getAllEmployees() { String sql = \"SELECT * FROM EMPLOYEE\"; Flowable&lt;Employee&gt; employeeFlowable = database.select(sql).get(rs -&gt; { return Employee.builder() .id(rs.getInt(\"id\")) .name(rs.getString(\"name\")) .build(); }); return Flux.from(employeeFlowable);}Note that rxjava2-jdbc returns Flowable, but we return a Flux instead for compatibility with Spring WebFlux. For more examples, see Spring WebFlux and rxjava2-jdbc.5. Code RepositoryYou can find the full source code on GitHub.6. References davidmoten/rxjava2-jdbc - GitHub Introduction to rxjava-jdbc - Baeldung Spring WebFlux and rxjava2-jdbc - Medium" }, { "title": "How did I Create this Blog", "url": "/posts/how-did-i-create-this-blog/", "categories": "Blogging, Tutorial", "tags": "jekyll, github-pages", "date": "2022-07-10 16:40:00 +0530", "snippet": "This is a step by step guide on how I created this blog and how you can create yours too.Most of the content here is sourced from the Chirpy website.Before I start, let me explain why I chose GitHub Pages and Jekyll with Chirpy theme. If you are convinced already and want to skip to the tutorial, click here.Why GitHub PagesWhat’s better than having the source code for your blog on GitHub with the convenience of automated deploys! It makes even more sense to have a tech focused blog hosted on GitHub (that too for free).Why Jekyll with ChirpyGitHub pages website has a Blogging with Jekyll article, which is convincing enough. For me, one look at the Chirpy website was all it needed to fall in love. If my blog can look like that, what’s stopping me?Creating the Site RepositoryCreate a new repository from the Chirpy Starter and name it &lt;GH_USERNAME&gt;.github.io, where GH_USERNAME represents your GitHub username.The repository I created is rai-sandeep.github.io.Installing JekyllFollow the instructions in the Jekyll Docs.The page has detailed instructions for different operating systems.If you are able to install everything successfully, skip to Installing Dependencies.Troubleshooting on MacI followed the guide for macOS, which lists the below terminal commands.$ brew install chruby ruby-install$ ruby-install ruby$ echo \"source $(brew --prefix)/opt/chruby/share/chruby/chruby.sh\" &gt;&gt; ~/.zshrc$ echo \"source $(brew --prefix)/opt/chruby/share/chruby/auto.sh\" &gt;&gt; ~/.zshrc$ echo \"chruby ruby-3.1.2\" &gt;&gt; ~/.zshrc$ ruby -v $ gem install jekyllYou need only these commands if your Homebrew and xcode command line tools are perfectly setup.Homebrew issuesBefore you start, run brew update and brew doctor to validate Homebrew. If it complains about shallow homebrew-core, run the unshallow command it suggests (git -C /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core fetch --unshallow in my case).Ruby issuesIf ruby installation complains about C libraries, make sure xcode command line is installed and run xcode-select --install if needed.Installing DependenciesOnce jekyll is installed, clone your repository, navigate to its root directory and install dependencies with the bundle command.$ bundleConfigurationUpdate the variables of _config.yml as needed. These are the variables I updated: timezone title tagline description github: username twitter: username social: name, email, links avatar comments: active, giscusSee my _config.yml here.AvatarPlace your picture or avatar in a directory and use it. Example: avatar: '/assets/images/sandeep.jpeg'CommentsIf you want to enable comments on your posts, disqus, utterances and giscus are the supported options.GiscusI chose Giscus, a comments system powered by GitHub Discussions. Head over to the Configuration section on their website for instructions. See below for the steps I followed. Create a public repository similar to this. Install giscus app. Enable Discussions feature for your repository. On the website, enter the repository and set Discussion Category as General. The Enable Giscus section should now show all the details needed for the _config.yml. See my configuration under comments here.About pageAdd details about yourself in the _tabs/about.md file (example).Running Local ServerYou may want to preview the site contents before publishing, so just run it by:$ bundle exec jekyll sAfter a while, the local service will be published at http://127.0.0.1:4000.DeploymentPush your changes to &lt;GH_USERNAME&gt;.github.io on GitHub.If you have committed Gemfile.lock to the repo, and your runtime system is not Linux, don’t forget to update the platform list in the lock file: $ bundle lock --add-platform x86_64-linuxNow publish your Jekyll site by: Push any commit to remote to trigger the GitHub Actions workflow. Once the build is complete and successful, a new remote branch named gh-pages will appear to store the built site files. Browse to your repository on GitHub. Select the tab Settings, then click Pages in the left navigation bar, and then in the section Source of GitHub Pages, select the /(root) directory of branch gh-pages as the publishing source. Remember to click Save before leaving. Visit your website at the address indicated by GitHub. Write your first postCongratulations! Your blog should now be online.The obvious next step is to add a post similar the one you are reading now (source code). Follow instructions on the Chirpy website and you should be set." } ]
